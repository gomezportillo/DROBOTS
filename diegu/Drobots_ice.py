# **********************************************************************
#
# Copyright (c) 2003-2015 ZeroC, Inc. All rights reserved.
#
# This copy of Ice is licensed to you under the terms described in the
# ICE_LICENSE file included in this distribution.
#
# **********************************************************************
#
# Ice version 3.6.1
#
# <auto-generated>
#
# Generated from file `Drobots.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

import Ice, IcePy

# Start of module drobots
_M_drobots = Ice.openModule('drobots')
__name__ = 'drobots'

if 'Point' not in _M_drobots.__dict__:
    _M_drobots.Point = Ice.createTempClass()
    class Point(object):
        def __init__(self, x=0, y=0):
            self.x = x
            self.y = y

        def __hash__(self):
            _h = 0
            _h = 5 * _h + Ice.getHash(self.x)
            _h = 5 * _h + Ice.getHash(self.y)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_drobots.Point):
                return NotImplemented
            else:
                if self.x is None or other.x is None:
                    if self.x != other.x:
                        return (-1 if self.x is None else 1)
                else:
                    if self.x < other.x:
                        return -1
                    elif self.x > other.x:
                        return 1
                if self.y is None or other.y is None:
                    if self.y != other.y:
                        return (-1 if self.y is None else 1)
                else:
                    if self.y < other.y:
                        return -1
                    elif self.y > other.y:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_drobots._t_Point)

        __repr__ = __str__

    _M_drobots._t_Point = IcePy.defineStruct('::drobots::Point', Point, (), (
        ('x', (), IcePy._t_int),
        ('y', (), IcePy._t_int)
    ))

    _M_drobots.Point = Point
    del Point

if 'NoEnoughEnergy' not in _M_drobots.__dict__:
    _M_drobots.NoEnoughEnergy = Ice.createTempClass()
    class NoEnoughEnergy(Ice.UserException):
        def __init__(self):
            pass

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_name = 'drobots::NoEnoughEnergy'

    _M_drobots._t_NoEnoughEnergy = IcePy.defineException('::drobots::NoEnoughEnergy', NoEnoughEnergy, (), False, None, ())
    NoEnoughEnergy._ice_type = _M_drobots._t_NoEnoughEnergy

    _M_drobots.NoEnoughEnergy = NoEnoughEnergy
    del NoEnoughEnergy

if 'RobotBase' not in _M_drobots.__dict__:
    _M_drobots.RobotBase = Ice.createTempClass()
    class RobotBase(Ice.Object):
        def __init__(self):
            if Ice.getType(self) == _M_drobots.RobotBase:
                raise RuntimeError('drobots.RobotBase is an abstract class')

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::drobots::RobotBase')

        def ice_id(self, current=None):
            return '::drobots::RobotBase'

        def ice_staticId():
            return '::drobots::RobotBase'
        ice_staticId = staticmethod(ice_staticId)

        def drive(self, angle, speed, current=None):
            pass

        def damage(self, current=None):
            pass

        def speed(self, current=None):
            pass

        def location(self, current=None):
            pass

        def energy(self, current=None):
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_drobots._t_RobotBase)

        __repr__ = __str__

    _M_drobots.RobotBasePrx = Ice.createTempClass()
    class RobotBasePrx(Ice.ObjectPrx):

        def drive(self, angle, speed, _ctx=None):
            return _M_drobots.RobotBase._op_drive.invoke(self, ((angle, speed), _ctx))

        def begin_drive(self, angle, speed, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_drobots.RobotBase._op_drive.begin(self, ((angle, speed), _response, _ex, _sent, _ctx))

        def end_drive(self, _r):
            return _M_drobots.RobotBase._op_drive.end(self, _r)

        def damage(self, _ctx=None):
            return _M_drobots.RobotBase._op_damage.invoke(self, ((), _ctx))

        def begin_damage(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_drobots.RobotBase._op_damage.begin(self, ((), _response, _ex, _sent, _ctx))

        def end_damage(self, _r):
            return _M_drobots.RobotBase._op_damage.end(self, _r)

        def speed(self, _ctx=None):
            return _M_drobots.RobotBase._op_speed.invoke(self, ((), _ctx))

        def begin_speed(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_drobots.RobotBase._op_speed.begin(self, ((), _response, _ex, _sent, _ctx))

        def end_speed(self, _r):
            return _M_drobots.RobotBase._op_speed.end(self, _r)

        def location(self, _ctx=None):
            return _M_drobots.RobotBase._op_location.invoke(self, ((), _ctx))

        def begin_location(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_drobots.RobotBase._op_location.begin(self, ((), _response, _ex, _sent, _ctx))

        def end_location(self, _r):
            return _M_drobots.RobotBase._op_location.end(self, _r)

        def energy(self, _ctx=None):
            return _M_drobots.RobotBase._op_energy.invoke(self, ((), _ctx))

        def begin_energy(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_drobots.RobotBase._op_energy.begin(self, ((), _response, _ex, _sent, _ctx))

        def end_energy(self, _r):
            return _M_drobots.RobotBase._op_energy.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_drobots.RobotBasePrx.ice_checkedCast(proxy, '::drobots::RobotBase', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_drobots.RobotBasePrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

        def ice_staticId():
            return '::drobots::RobotBase'
        ice_staticId = staticmethod(ice_staticId)

    _M_drobots._t_RobotBasePrx = IcePy.defineProxy('::drobots::RobotBase', RobotBasePrx)

    _M_drobots._t_RobotBase = IcePy.defineClass('::drobots::RobotBase', RobotBase, -1, (), True, False, None, (), ())
    RobotBase._ice_type = _M_drobots._t_RobotBase

    RobotBase._op_drive = IcePy.Operation('drive', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_int, False, 0), ((), IcePy._t_int, False, 0)), (), None, (_M_drobots._t_NoEnoughEnergy,))
    RobotBase._op_damage = IcePy.Operation('damage', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), IcePy._t_short, False, 0), (_M_drobots._t_NoEnoughEnergy,))
    RobotBase._op_speed = IcePy.Operation('speed', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), IcePy._t_short, False, 0), (_M_drobots._t_NoEnoughEnergy,))
    RobotBase._op_location = IcePy.Operation('location', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), _M_drobots._t_Point, False, 0), (_M_drobots._t_NoEnoughEnergy,))
    RobotBase._op_energy = IcePy.Operation('energy', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), IcePy._t_short, False, 0), (_M_drobots._t_NoEnoughEnergy,))

    _M_drobots.RobotBase = RobotBase
    del RobotBase

    _M_drobots.RobotBasePrx = RobotBasePrx
    del RobotBasePrx

if 'Attacker' not in _M_drobots.__dict__:
    _M_drobots.Attacker = Ice.createTempClass()
    class Attacker(_M_drobots.RobotBase):
        def __init__(self):
            if Ice.getType(self) == _M_drobots.Attacker:
                raise RuntimeError('drobots.Attacker is an abstract class')

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::drobots::Attacker', '::drobots::RobotBase')

        def ice_id(self, current=None):
            return '::drobots::Attacker'

        def ice_staticId():
            return '::drobots::Attacker'
        ice_staticId = staticmethod(ice_staticId)

        def cannon(self, angle, distance, current=None):
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_drobots._t_Attacker)

        __repr__ = __str__

    _M_drobots.AttackerPrx = Ice.createTempClass()
    class AttackerPrx(_M_drobots.RobotBasePrx):

        def cannon(self, angle, distance, _ctx=None):
            return _M_drobots.Attacker._op_cannon.invoke(self, ((angle, distance), _ctx))

        def begin_cannon(self, angle, distance, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_drobots.Attacker._op_cannon.begin(self, ((angle, distance), _response, _ex, _sent, _ctx))

        def end_cannon(self, _r):
            return _M_drobots.Attacker._op_cannon.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_drobots.AttackerPrx.ice_checkedCast(proxy, '::drobots::Attacker', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_drobots.AttackerPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

        def ice_staticId():
            return '::drobots::Attacker'
        ice_staticId = staticmethod(ice_staticId)

    _M_drobots._t_AttackerPrx = IcePy.defineProxy('::drobots::Attacker', AttackerPrx)

    _M_drobots._t_Attacker = IcePy.defineClass('::drobots::Attacker', Attacker, -1, (), True, False, None, (_M_drobots._t_RobotBase,), ())
    Attacker._ice_type = _M_drobots._t_Attacker

    Attacker._op_cannon = IcePy.Operation('cannon', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_int, False, 0), ((), IcePy._t_int, False, 0)), (), ((), IcePy._t_bool, False, 0), (_M_drobots._t_NoEnoughEnergy,))

    _M_drobots.Attacker = Attacker
    del Attacker

    _M_drobots.AttackerPrx = AttackerPrx
    del AttackerPrx

if 'Defender' not in _M_drobots.__dict__:
    _M_drobots.Defender = Ice.createTempClass()
    class Defender(_M_drobots.RobotBase):
        def __init__(self):
            if Ice.getType(self) == _M_drobots.Defender:
                raise RuntimeError('drobots.Defender is an abstract class')

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::drobots::Defender', '::drobots::RobotBase')

        def ice_id(self, current=None):
            return '::drobots::Defender'

        def ice_staticId():
            return '::drobots::Defender'
        ice_staticId = staticmethod(ice_staticId)

        def scan(self, angle, wide, current=None):
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_drobots._t_Defender)

        __repr__ = __str__

    _M_drobots.DefenderPrx = Ice.createTempClass()
    class DefenderPrx(_M_drobots.RobotBasePrx):

        def scan(self, angle, wide, _ctx=None):
            return _M_drobots.Defender._op_scan.invoke(self, ((angle, wide), _ctx))

        def begin_scan(self, angle, wide, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_drobots.Defender._op_scan.begin(self, ((angle, wide), _response, _ex, _sent, _ctx))

        def end_scan(self, _r):
            return _M_drobots.Defender._op_scan.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_drobots.DefenderPrx.ice_checkedCast(proxy, '::drobots::Defender', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_drobots.DefenderPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

        def ice_staticId():
            return '::drobots::Defender'
        ice_staticId = staticmethod(ice_staticId)

    _M_drobots._t_DefenderPrx = IcePy.defineProxy('::drobots::Defender', DefenderPrx)

    _M_drobots._t_Defender = IcePy.defineClass('::drobots::Defender', Defender, -1, (), True, False, None, (_M_drobots._t_RobotBase,), ())
    Defender._ice_type = _M_drobots._t_Defender

    Defender._op_scan = IcePy.Operation('scan', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_int, False, 0), ((), IcePy._t_int, False, 0)), (), ((), IcePy._t_int, False, 0), (_M_drobots._t_NoEnoughEnergy,))

    _M_drobots.Defender = Defender
    del Defender

    _M_drobots.DefenderPrx = DefenderPrx
    del DefenderPrx

if 'Robot' not in _M_drobots.__dict__:
    _M_drobots.Robot = Ice.createTempClass()
    class Robot(_M_drobots.Attacker, _M_drobots.Defender):
        def __init__(self):
            if Ice.getType(self) == _M_drobots.Robot:
                raise RuntimeError('drobots.Robot is an abstract class')

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::drobots::Attacker', '::drobots::Defender', '::drobots::Robot', '::drobots::RobotBase')

        def ice_id(self, current=None):
            return '::drobots::Robot'

        def ice_staticId():
            return '::drobots::Robot'
        ice_staticId = staticmethod(ice_staticId)

        def __str__(self):
            return IcePy.stringify(self, _M_drobots._t_Robot)

        __repr__ = __str__

    _M_drobots.RobotPrx = Ice.createTempClass()
    class RobotPrx(_M_drobots.AttackerPrx, _M_drobots.DefenderPrx):

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_drobots.RobotPrx.ice_checkedCast(proxy, '::drobots::Robot', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_drobots.RobotPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

        def ice_staticId():
            return '::drobots::Robot'
        ice_staticId = staticmethod(ice_staticId)

    _M_drobots._t_RobotPrx = IcePy.defineProxy('::drobots::Robot', RobotPrx)

    _M_drobots._t_Robot = IcePy.defineClass('::drobots::Robot', Robot, -1, (), True, False, None, (_M_drobots._t_Attacker, _M_drobots._t_Defender), ())
    Robot._ice_type = _M_drobots._t_Robot

    _M_drobots.Robot = Robot
    del Robot

    _M_drobots.RobotPrx = RobotPrx
    del RobotPrx

if 'RobotController' not in _M_drobots.__dict__:
    _M_drobots.RobotController = Ice.createTempClass()
    class RobotController(Ice.Object):
        def __init__(self):
            if Ice.getType(self) == _M_drobots.RobotController:
                raise RuntimeError('drobots.RobotController is an abstract class')

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::drobots::RobotController')

        def ice_id(self, current=None):
            return '::drobots::RobotController'

        def ice_staticId():
            return '::drobots::RobotController'
        ice_staticId = staticmethod(ice_staticId)

        def turn(self, current=None):
            pass

        def robotDestroyed(self, current=None):
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_drobots._t_RobotController)

        __repr__ = __str__

    _M_drobots.RobotControllerPrx = Ice.createTempClass()
    class RobotControllerPrx(Ice.ObjectPrx):

        def turn(self, _ctx=None):
            return _M_drobots.RobotController._op_turn.invoke(self, ((), _ctx))

        def begin_turn(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_drobots.RobotController._op_turn.begin(self, ((), _response, _ex, _sent, _ctx))

        def end_turn(self, _r):
            return _M_drobots.RobotController._op_turn.end(self, _r)

        def robotDestroyed(self, _ctx=None):
            return _M_drobots.RobotController._op_robotDestroyed.invoke(self, ((), _ctx))

        def begin_robotDestroyed(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_drobots.RobotController._op_robotDestroyed.begin(self, ((), _response, _ex, _sent, _ctx))

        def end_robotDestroyed(self, _r):
            return _M_drobots.RobotController._op_robotDestroyed.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_drobots.RobotControllerPrx.ice_checkedCast(proxy, '::drobots::RobotController', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_drobots.RobotControllerPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

        def ice_staticId():
            return '::drobots::RobotController'
        ice_staticId = staticmethod(ice_staticId)

    _M_drobots._t_RobotControllerPrx = IcePy.defineProxy('::drobots::RobotController', RobotControllerPrx)

    _M_drobots._t_RobotController = IcePy.defineClass('::drobots::RobotController', RobotController, -1, (), True, False, None, (), ())
    RobotController._ice_type = _M_drobots._t_RobotController

    RobotController._op_turn = IcePy.Operation('turn', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, ())
    RobotController._op_robotDestroyed = IcePy.Operation('robotDestroyed', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, ())

    _M_drobots.RobotController = RobotController
    del RobotController

    _M_drobots.RobotControllerPrx = RobotControllerPrx
    del RobotControllerPrx

if 'Player' not in _M_drobots.__dict__:
    _M_drobots.Player = Ice.createTempClass()
    class Player(Ice.Object):
        def __init__(self):
            if Ice.getType(self) == _M_drobots.Player:
                raise RuntimeError('drobots.Player is an abstract class')

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::drobots::Player')

        def ice_id(self, current=None):
            return '::drobots::Player'

        def ice_staticId():
            return '::drobots::Player'
        ice_staticId = staticmethod(ice_staticId)

        def makeController(self, bot, current=None):
            pass

        def win(self, current=None):
            pass

        def lose(self, current=None):
            pass

        def gameAbort(self, current=None):
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_drobots._t_Player)

        __repr__ = __str__

    _M_drobots.PlayerPrx = Ice.createTempClass()
    class PlayerPrx(Ice.ObjectPrx):

        def makeController(self, bot, _ctx=None):
            return _M_drobots.Player._op_makeController.invoke(self, ((bot, ), _ctx))

        def begin_makeController(self, bot, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_drobots.Player._op_makeController.begin(self, ((bot, ), _response, _ex, _sent, _ctx))

        def end_makeController(self, _r):
            return _M_drobots.Player._op_makeController.end(self, _r)

        def win(self, _ctx=None):
            return _M_drobots.Player._op_win.invoke(self, ((), _ctx))

        def begin_win(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_drobots.Player._op_win.begin(self, ((), _response, _ex, _sent, _ctx))

        def end_win(self, _r):
            return _M_drobots.Player._op_win.end(self, _r)

        def lose(self, _ctx=None):
            return _M_drobots.Player._op_lose.invoke(self, ((), _ctx))

        def begin_lose(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_drobots.Player._op_lose.begin(self, ((), _response, _ex, _sent, _ctx))

        def end_lose(self, _r):
            return _M_drobots.Player._op_lose.end(self, _r)

        def gameAbort(self, _ctx=None):
            return _M_drobots.Player._op_gameAbort.invoke(self, ((), _ctx))

        def begin_gameAbort(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_drobots.Player._op_gameAbort.begin(self, ((), _response, _ex, _sent, _ctx))

        def end_gameAbort(self, _r):
            return _M_drobots.Player._op_gameAbort.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_drobots.PlayerPrx.ice_checkedCast(proxy, '::drobots::Player', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_drobots.PlayerPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

        def ice_staticId():
            return '::drobots::Player'
        ice_staticId = staticmethod(ice_staticId)

    _M_drobots._t_PlayerPrx = IcePy.defineProxy('::drobots::Player', PlayerPrx)

    _M_drobots._t_Player = IcePy.defineClass('::drobots::Player', Player, -1, (), True, False, None, (), ())
    Player._ice_type = _M_drobots._t_Player

    Player._op_makeController = IcePy.Operation('makeController', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_drobots._t_RobotPrx, False, 0),), (), ((), _M_drobots._t_RobotControllerPrx, False, 0), ())
    Player._op_win = IcePy.Operation('win', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, ())
    Player._op_lose = IcePy.Operation('lose', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, ())
    Player._op_gameAbort = IcePy.Operation('gameAbort', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, ())

    _M_drobots.Player = Player
    del Player

    _M_drobots.PlayerPrx = PlayerPrx
    del PlayerPrx

if 'GameInProgress' not in _M_drobots.__dict__:
    _M_drobots.GameInProgress = Ice.createTempClass()
    class GameInProgress(Ice.UserException):
        def __init__(self):
            pass

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_name = 'drobots::GameInProgress'

    _M_drobots._t_GameInProgress = IcePy.defineException('::drobots::GameInProgress', GameInProgress, (), False, None, ())
    GameInProgress._ice_type = _M_drobots._t_GameInProgress

    _M_drobots.GameInProgress = GameInProgress
    del GameInProgress

if 'InvalidProxy' not in _M_drobots.__dict__:
    _M_drobots.InvalidProxy = Ice.createTempClass()
    class InvalidProxy(Ice.UserException):
        def __init__(self):
            pass

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_name = 'drobots::InvalidProxy'

    _M_drobots._t_InvalidProxy = IcePy.defineException('::drobots::InvalidProxy', InvalidProxy, (), False, None, ())
    InvalidProxy._ice_type = _M_drobots._t_InvalidProxy

    _M_drobots.InvalidProxy = InvalidProxy
    del InvalidProxy

if 'InvalidName' not in _M_drobots.__dict__:
    _M_drobots.InvalidName = Ice.createTempClass()
    class InvalidName(Ice.UserException):
        def __init__(self, reason=''):
            self.reason = reason

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_name = 'drobots::InvalidName'

    _M_drobots._t_InvalidName = IcePy.defineException('::drobots::InvalidName', InvalidName, (), False, None, (('reason', (), IcePy._t_string, False, 0),))
    InvalidName._ice_type = _M_drobots._t_InvalidName

    _M_drobots.InvalidName = InvalidName
    del InvalidName

if 'Game' not in _M_drobots.__dict__:
    _M_drobots.Game = Ice.createTempClass()
    class Game(Ice.Object):
        def __init__(self):
            if Ice.getType(self) == _M_drobots.Game:
                raise RuntimeError('drobots.Game is an abstract class')

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::drobots::Game')

        def ice_id(self, current=None):
            return '::drobots::Game'

        def ice_staticId():
            return '::drobots::Game'
        ice_staticId = staticmethod(ice_staticId)

        def login(self, p, nick, current=None):
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_drobots._t_Game)

        __repr__ = __str__

    _M_drobots.GamePrx = Ice.createTempClass()
    class GamePrx(Ice.ObjectPrx):

        def login(self, p, nick, _ctx=None):
            return _M_drobots.Game._op_login.invoke(self, ((p, nick), _ctx))

        def begin_login(self, p, nick, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_drobots.Game._op_login.begin(self, ((p, nick), _response, _ex, _sent, _ctx))

        def end_login(self, _r):
            return _M_drobots.Game._op_login.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_drobots.GamePrx.ice_checkedCast(proxy, '::drobots::Game', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_drobots.GamePrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

        def ice_staticId():
            return '::drobots::Game'
        ice_staticId = staticmethod(ice_staticId)

    _M_drobots._t_GamePrx = IcePy.defineProxy('::drobots::Game', GamePrx)

    _M_drobots._t_Game = IcePy.defineClass('::drobots::Game', Game, -1, (), True, False, None, (), ())
    Game._ice_type = _M_drobots._t_Game

    Game._op_login = IcePy.Operation('login', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_drobots._t_PlayerPrx, False, 0), ((), IcePy._t_string, False, 0)), (), None, (_M_drobots._t_GameInProgress, _M_drobots._t_InvalidProxy, _M_drobots._t_InvalidName))

    _M_drobots.Game = Game
    del Game

    _M_drobots.GamePrx = GamePrx
    del GamePrx

# End of module drobots
