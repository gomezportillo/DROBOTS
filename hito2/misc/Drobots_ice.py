# **********************************************************************
#
# Copyright (c) 2003-2015 ZeroC, Inc. All rights reserved.
#
# This copy of Ice is licensed to you under the terms described in the
# ICE_LICENSE file included in this distribution.
#
# **********************************************************************
#
# Ice version 3.6.1
#
# <auto-generated>
#
# Generated from file `Drobots.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

import Ice, IcePy

# Start of module drobots
_M_drobots = Ice.openModule('drobots')
__name__ = 'drobots'

if 'Point' not in _M_drobots.__dict__:
    _M_drobots.Point = Ice.createTempClass()
    class Point(object):
        def __init__(self, x=0, y=0):
            self.x = x
            self.y = y

        def __hash__(self):
            _h = 0
            _h = 5 * _h + Ice.getHash(self.x)
            _h = 5 * _h + Ice.getHash(self.y)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_drobots.Point):
                return NotImplemented
            else:
                if self.x is None or other.x is None:
                    if self.x != other.x:
                        return (-1 if self.x is None else 1)
                else:
                    if self.x < other.x:
                        return -1
                    elif self.x > other.x:
                        return 1
                if self.y is None or other.y is None:
                    if self.y != other.y:
                        return (-1 if self.y is None else 1)
                else:
                    if self.y < other.y:
                        return -1
                    elif self.y > other.y:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_drobots._t_Point)

        __repr__ = __str__

    _M_drobots._t_Point = IcePy.defineStruct('::drobots::Point', Point, (), (
        ('x', (), IcePy._t_int),
        ('y', (), IcePy._t_int)
    ))

    _M_drobots.Point = Point
    del Point

if 'Robot' not in _M_drobots.__dict__:
    _M_drobots.Robot = Ice.createTempClass()
    class Robot(Ice.Object):
        def __init__(self):
            if Ice.getType(self) == _M_drobots.Robot:
                raise RuntimeError('drobots.Robot is an abstract class')

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::drobots::Robot')

        def ice_id(self, current=None):
            return '::drobots::Robot'

        def ice_staticId():
            return '::drobots::Robot'
        ice_staticId = staticmethod(ice_staticId)

        def scan(self, angle, wide, current=None):
            pass

        def cannon(self, angle, distance, current=None):
            pass

        def drive(self, angle, speed, current=None):
            pass

        def damage(self, current=None):
            pass

        def speed(self, current=None):
            pass

        def location(self, current=None):
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_drobots._t_Robot)

        __repr__ = __str__

    _M_drobots.RobotPrx = Ice.createTempClass()
    class RobotPrx(Ice.ObjectPrx):

        def scan(self, angle, wide, _ctx=None):
            return _M_drobots.Robot._op_scan.invoke(self, ((angle, wide), _ctx))

        def begin_scan(self, angle, wide, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_drobots.Robot._op_scan.begin(self, ((angle, wide), _response, _ex, _sent, _ctx))

        def end_scan(self, _r):
            return _M_drobots.Robot._op_scan.end(self, _r)

        def cannon(self, angle, distance, _ctx=None):
            return _M_drobots.Robot._op_cannon.invoke(self, ((angle, distance), _ctx))

        def begin_cannon(self, angle, distance, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_drobots.Robot._op_cannon.begin(self, ((angle, distance), _response, _ex, _sent, _ctx))

        def end_cannon(self, _r):
            return _M_drobots.Robot._op_cannon.end(self, _r)

        def drive(self, angle, speed, _ctx=None):
            return _M_drobots.Robot._op_drive.invoke(self, ((angle, speed), _ctx))

        def begin_drive(self, angle, speed, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_drobots.Robot._op_drive.begin(self, ((angle, speed), _response, _ex, _sent, _ctx))

        def end_drive(self, _r):
            return _M_drobots.Robot._op_drive.end(self, _r)

        def damage(self, _ctx=None):
            return _M_drobots.Robot._op_damage.invoke(self, ((), _ctx))

        def begin_damage(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_drobots.Robot._op_damage.begin(self, ((), _response, _ex, _sent, _ctx))

        def end_damage(self, _r):
            return _M_drobots.Robot._op_damage.end(self, _r)

        def speed(self, _ctx=None):
            return _M_drobots.Robot._op_speed.invoke(self, ((), _ctx))

        def begin_speed(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_drobots.Robot._op_speed.begin(self, ((), _response, _ex, _sent, _ctx))

        def end_speed(self, _r):
            return _M_drobots.Robot._op_speed.end(self, _r)

        def location(self, _ctx=None):
            return _M_drobots.Robot._op_location.invoke(self, ((), _ctx))

        def begin_location(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_drobots.Robot._op_location.begin(self, ((), _response, _ex, _sent, _ctx))

        def end_location(self, _r):
            return _M_drobots.Robot._op_location.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_drobots.RobotPrx.ice_checkedCast(proxy, '::drobots::Robot', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_drobots.RobotPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

        def ice_staticId():
            return '::drobots::Robot'
        ice_staticId = staticmethod(ice_staticId)

    _M_drobots._t_RobotPrx = IcePy.defineProxy('::drobots::Robot', RobotPrx)

    _M_drobots._t_Robot = IcePy.defineClass('::drobots::Robot', Robot, -1, (), True, False, None, (), ())
    Robot._ice_type = _M_drobots._t_Robot

    Robot._op_scan = IcePy.Operation('scan', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_int, False, 0), ((), IcePy._t_int, False, 0)), (), ((), IcePy._t_int, False, 0), ())
    Robot._op_cannon = IcePy.Operation('cannon', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_int, False, 0), ((), IcePy._t_int, False, 0)), (), ((), IcePy._t_bool, False, 0), ())
    Robot._op_drive = IcePy.Operation('drive', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_int, False, 0), ((), IcePy._t_int, False, 0)), (), None, ())
    Robot._op_damage = IcePy.Operation('damage', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), IcePy._t_short, False, 0), ())
    Robot._op_speed = IcePy.Operation('speed', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), IcePy._t_int, False, 0), ())
    Robot._op_location = IcePy.Operation('location', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), _M_drobots._t_Point, False, 0), ())

    _M_drobots.Robot = Robot
    del Robot

    _M_drobots.RobotPrx = RobotPrx
    del RobotPrx

if 'RobotController' not in _M_drobots.__dict__:
    _M_drobots.RobotController = Ice.createTempClass()
    class RobotController(Ice.Object):
        def __init__(self):
            if Ice.getType(self) == _M_drobots.RobotController:
                raise RuntimeError('drobots.RobotController is an abstract class')

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::drobots::RobotController')

        def ice_id(self, current=None):
            return '::drobots::RobotController'

        def ice_staticId():
            return '::drobots::RobotController'
        ice_staticId = staticmethod(ice_staticId)

        def turn(self, current=None):
            pass

        def robotDestroyed(self, current=None):
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_drobots._t_RobotController)

        __repr__ = __str__

    _M_drobots.RobotControllerPrx = Ice.createTempClass()
    class RobotControllerPrx(Ice.ObjectPrx):

        def turn(self, _ctx=None):
            return _M_drobots.RobotController._op_turn.invoke(self, ((), _ctx))

        def begin_turn(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_drobots.RobotController._op_turn.begin(self, ((), _response, _ex, _sent, _ctx))

        def end_turn(self, _r):
            return _M_drobots.RobotController._op_turn.end(self, _r)

        def robotDestroyed(self, _ctx=None):
            return _M_drobots.RobotController._op_robotDestroyed.invoke(self, ((), _ctx))

        def begin_robotDestroyed(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_drobots.RobotController._op_robotDestroyed.begin(self, ((), _response, _ex, _sent, _ctx))

        def end_robotDestroyed(self, _r):
            return _M_drobots.RobotController._op_robotDestroyed.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_drobots.RobotControllerPrx.ice_checkedCast(proxy, '::drobots::RobotController', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_drobots.RobotControllerPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

        def ice_staticId():
            return '::drobots::RobotController'
        ice_staticId = staticmethod(ice_staticId)

    _M_drobots._t_RobotControllerPrx = IcePy.defineProxy('::drobots::RobotController', RobotControllerPrx)

    _M_drobots._t_RobotController = IcePy.defineClass('::drobots::RobotController', RobotController, -1, (), True, False, None, (), ())
    RobotController._ice_type = _M_drobots._t_RobotController

    RobotController._op_turn = IcePy.Operation('turn', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, ())
    RobotController._op_robotDestroyed = IcePy.Operation('robotDestroyed', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, ())

    _M_drobots.RobotController = RobotController
    del RobotController

    _M_drobots.RobotControllerPrx = RobotControllerPrx
    del RobotControllerPrx

if 'Player' not in _M_drobots.__dict__:
    _M_drobots.Player = Ice.createTempClass()
    class Player(Ice.Object):
        def __init__(self):
            if Ice.getType(self) == _M_drobots.Player:
                raise RuntimeError('drobots.Player is an abstract class')

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::drobots::Player')

        def ice_id(self, current=None):
            return '::drobots::Player'

        def ice_staticId():
            return '::drobots::Player'
        ice_staticId = staticmethod(ice_staticId)

        def makeController(self, bot, current=None):
            pass

        def win(self, current=None):
            pass

        def lose(self, current=None):
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_drobots._t_Player)

        __repr__ = __str__

    _M_drobots.PlayerPrx = Ice.createTempClass()
    class PlayerPrx(Ice.ObjectPrx):

        def makeController(self, bot, _ctx=None):
            return _M_drobots.Player._op_makeController.invoke(self, ((bot, ), _ctx))

        def begin_makeController(self, bot, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_drobots.Player._op_makeController.begin(self, ((bot, ), _response, _ex, _sent, _ctx))

        def end_makeController(self, _r):
            return _M_drobots.Player._op_makeController.end(self, _r)

        def win(self, _ctx=None):
            return _M_drobots.Player._op_win.invoke(self, ((), _ctx))

        def begin_win(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_drobots.Player._op_win.begin(self, ((), _response, _ex, _sent, _ctx))

        def end_win(self, _r):
            return _M_drobots.Player._op_win.end(self, _r)

        def lose(self, _ctx=None):
            return _M_drobots.Player._op_lose.invoke(self, ((), _ctx))

        def begin_lose(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_drobots.Player._op_lose.begin(self, ((), _response, _ex, _sent, _ctx))

        def end_lose(self, _r):
            return _M_drobots.Player._op_lose.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_drobots.PlayerPrx.ice_checkedCast(proxy, '::drobots::Player', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_drobots.PlayerPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

        def ice_staticId():
            return '::drobots::Player'
        ice_staticId = staticmethod(ice_staticId)

    _M_drobots._t_PlayerPrx = IcePy.defineProxy('::drobots::Player', PlayerPrx)

    _M_drobots._t_Player = IcePy.defineClass('::drobots::Player', Player, -1, (), True, False, None, (), ())
    Player._ice_type = _M_drobots._t_Player

    Player._op_makeController = IcePy.Operation('makeController', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_drobots._t_RobotPrx, False, 0),), (), ((), _M_drobots._t_RobotControllerPrx, False, 0), ())
    Player._op_win = IcePy.Operation('win', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, ())
    Player._op_lose = IcePy.Operation('lose', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, ())

    _M_drobots.Player = Player
    del Player

    _M_drobots.PlayerPrx = PlayerPrx
    del PlayerPrx

if 'GameInProgress' not in _M_drobots.__dict__:
    _M_drobots.GameInProgress = Ice.createTempClass()
    class GameInProgress(Ice.UserException):
        def __init__(self):
            pass

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_name = 'drobots::GameInProgress'

    _M_drobots._t_GameInProgress = IcePy.defineException('::drobots::GameInProgress', GameInProgress, (), False, None, ())
    GameInProgress._ice_type = _M_drobots._t_GameInProgress

    _M_drobots.GameInProgress = GameInProgress
    del GameInProgress

if 'Game' not in _M_drobots.__dict__:
    _M_drobots.Game = Ice.createTempClass()
    class Game(Ice.Object):
        def __init__(self):
            if Ice.getType(self) == _M_drobots.Game:
                raise RuntimeError('drobots.Game is an abstract class')

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::drobots::Game')

        def ice_id(self, current=None):
            return '::drobots::Game'

        def ice_staticId():
            return '::drobots::Game'
        ice_staticId = staticmethod(ice_staticId)

        def attach(self, p, current=None):
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_drobots._t_Game)

        __repr__ = __str__

    _M_drobots.GamePrx = Ice.createTempClass()
    class GamePrx(Ice.ObjectPrx):

        def attach(self, p, _ctx=None):
            return _M_drobots.Game._op_attach.invoke(self, ((p, ), _ctx))

        def begin_attach(self, p, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_drobots.Game._op_attach.begin(self, ((p, ), _response, _ex, _sent, _ctx))

        def end_attach(self, _r):
            return _M_drobots.Game._op_attach.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_drobots.GamePrx.ice_checkedCast(proxy, '::drobots::Game', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_drobots.GamePrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

        def ice_staticId():
            return '::drobots::Game'
        ice_staticId = staticmethod(ice_staticId)

    _M_drobots._t_GamePrx = IcePy.defineProxy('::drobots::Game', GamePrx)

    _M_drobots._t_Game = IcePy.defineClass('::drobots::Game', Game, -1, (), True, False, None, (), ())
    Game._ice_type = _M_drobots._t_Game

    Game._op_attach = IcePy.Operation('attach', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_drobots._t_PlayerPrx, False, 0),), (), None, (_M_drobots._t_GameInProgress,))

    _M_drobots.Game = Game
    del Game

    _M_drobots.GamePrx = GamePrx
    del GamePrx

# End of module drobots
